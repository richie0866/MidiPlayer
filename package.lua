local Rostruct = (function() local a={_G={}}setmetatable(a,{__index=function(self,b)if b=="Promise"then self.Promise=a.initialize("modules","Promise")return self.Promise end end})local c;do c={}c.__index=c;function c.new(d)local e,f=string.match(d,"([^/]+)(/*)$")return setmetatable({name=e,path=string.sub(d,1,-#e-(f~=""and 2 or 1))},c)end;function c:__index(b)if b=="Parent"then return c.new(self.path)end end end;local g;do g={}g.__index=g;function g.new(d,h,i)return setmetatable({path=h~="init"and d or c.new(d).path,name=h,func=i,data=nil},g)end;function g:__index(b)if g[b]then return g[b]elseif b=="Parent"then return c.new(self.path)elseif b=="Name"then return self.path end end;function g:require()if self.func then self.data=self.func()self.func=nil end;return self.data end;function g:GetFullName()return self.path end end;local j;do j={}j.__index=j;setmetatable(j,{__call=function(k,l)local self=setmetatable({},j)self.description="Symbol("..(l or"")..")"return self end})local m=setmetatable({},{__index=function(self,b)self[b]=j(b)return self[b]end})function j:toString()return self.description end;j.__tostring=j.toString;function j.getFor(n)return m[n]end;function j.keyFor(o)for n,p in pairs(m)do if p==o then return n end end end end;a.Symbol=j;a.Symbol_iterator=j("Symbol.iterator")local q={}local r={}function a.register(d,h,i)local s=g.new(d,h,i)q[d]=s;r[h]=s;return s end;function a.get(d)return q[d]end;function a.initialize(...)local p=setmetatable({},{__tostring=function()return"root"end})local t=a.register(p,p)return a.import(t,{path="out/"},...)end;function a.getModule(u,v)return error("TS.getModule is not supported",2)end;local w={}local x={}function a.import(t,y,...)local z=y.path..table.concat({...},"/")..".lua"local A=y.path..table.concat({...},"/").."/init.lua"local s=assert(q[z]or q[A],"No module exists at path '"..z.."'")w[t]=s;local B=s;local C=0;while B do C=C+1;B=w[B]if B==s then local D=B.name;for k=1,C do B=w[B]D=D.." => "..B.name end;error("Failed to import! Detected a circular dependency chain: "..D,2)end end;if not x[s]then if a._G[s]then error("Invalid module access! Do you have two TS runtimes trying to import this? "..s.path,2)end;a._G[s]=a;x[s]=true end;local E=s:require()if w[t]==s then w[t]=nil end;return E end;function a.async(F)local G=a.Promise;return function(...)local H=select("#",...)local I={...}return G.new(function(J,K)coroutine.wrap(function()local L,M=pcall(F,unpack(I,1,H))if L then J(M)else K(M)end end)()end)end end;function a.await(N)local G=a.Promise;if not G.is(N)then return N end;local O,P=N:awaitStatus()if O==G.Status.Resolved then return P elseif O==G.Status.Rejected then error(P,2)else error("The awaited Promise was cancelled",2)end end;function a.opcall(i,...)local Q,R=pcall(i,...)if Q then return{success=true,value=R}else return{success=false,error=R}end end;a.register("out/Package.lua","Package",function()local S=a.get("out/Package.lua")local a=a._G[S]local T=a.import(S,S.Parent,"core")local U=T.Session;local V=T.VirtualScript;local W=a.import(S,S.Parent,"utils","file-utils").pathUtils;local X=a.import(S,S.Parent,"modules","make")local Y;do Y=setmetatable({},{__tostring=function()return"Package"end})Y.__index=Y;function Y.new(...)local self=setmetatable({},Y)return self:constructor(...)or self end;function Y:constructor(Z,_)self.tree=X("Folder",{Name="Tree"})local a0=type(Z)=="string"assert(a0,"(Package) The path must be a string")local a1=isfolder(Z)local a2="(Package) The path '"..Z.."' must be a valid directory"assert(a1,a2)self.root=W.formatPath(Z)self.session=U.new(Z)self.fetchInfo=_ end;function Y:build(a3,a4)if a3==nil then a3=""end;local a0=isfile(self.root..a3)or isfolder(self.root..a3)local a2="(Package.build) The path '"..self.root..a3 .."' must be a file or folder"assert(a0,a2)local a5=self.session:build(a3)local a6="(Package.build) The path '"..self.root..a3 .."' could not be turned into an Instance"assert(a5,a6)if a4~=nil then for a7,P in pairs(a4)do a5[a7]=P end end;a5.Parent=self.tree;return a5 end;function Y:start()return self.session:simulate()end;Y.require=a.async(function(self,s)local a0=s.ClassName=="ModuleScript"local a2="(Package.require) '"..tostring(s).."' must be a module"assert(a0,a2)local a1=s:IsDescendantOf(self.tree)local a6="(Package.require) '"..tostring(s).."' must be a descendant of Package.tree"assert(a1,a6)return V:requireFromInstance(s)end)function Y:requireAsync(s)return self:require(s):expect()end;Y.fromFetch=function(_)return Y.new(_.location,_)end end;return{Package=Y}end)a.register("out/bootstrap.lua","bootstrap",function()local S=a.get("out/bootstrap.lua")local a=a._G[S]local a8=a.import(S,S.Parent,"utils","file-utils").makeUtils;local a9={ROOT="rostruct/",CACHE="rostruct/cache/",RELEASE_CACHE="rostruct/cache/releases/",RELEASE_TAGS="rostruct/cache/release_tags.json"}local aa=function(ab)return a9[ab]end;local ac=function()return a8.makeFiles({{"rostruct/cache/releases/",""},{"rostruct/cache/release_tags.json","{}"}})end;return{getRostructPath=aa,bootstrap=ac}end)a.register("out/init.lua","init",function()local S=a.get("out/init.lua")local a=a._G[S]local ac=a.import(S,S,"bootstrap").bootstrap;ac()local Y=a.import(S,S,"Package").Package;local ad=a.import(S,S,"utils","fetch-github-release")local ae=ad.clearReleaseCache;local af=ad.downloadLatestRelease;local ag=ad.downloadRelease;local ah=function()return ae()end;local ai=function(Z)return Y.new(Z)end;local aj=a.async(function(...)local I={...}return Y.fromFetch(a.await(ag(unpack(I))))end)local ak=function(...)local I={...}return Y.fromFetch(ag(unpack(I)):expect())end;local al=a.async(function(...)local I={...}return Y.fromFetch(a.await(af(unpack(I))))end)local am=function(...)local I={...}return Y.fromFetch(af(unpack(I)):expect())end;return{clearCache=ah,open=ai,fetch=aj,fetchAsync=ak,fetchLatest=al,fetchLatestAsync=am}end)a.register("out/api/compatibility.lua","compatibility",function()local S=a.get("out/api/compatibility.lua")local an=request or(syn.request or http.request)local ao=getcustomasset or getsynasset;return{httpRequest=an,getContentId=ao}end)a.register("out/api/init.lua","init",function()local S=a.get("out/api/init.lua")local a=a._G[S]local ap={}for aq,ar in pairs(a.import(S,S,"compatibility"))do ap[aq]=ar end;return ap end)a.register("out/core/Session.lua","Session",function()local S=a.get("out/core/Session.lua")local a=a._G[S]local as=a.import(S,S.Parent,"Store").Store;local at=a.import(S,S.Parent.Parent,"modules","services").HttpService;local au=a.import(S,S.Parent,"build").build;local U;do U=setmetatable({},{__tostring=function()return"Session"end})U.__index=U;function U.new(...)local self=setmetatable({},U)return self:constructor(...)or self end;function U:constructor(Z)self.root=Z;self.sessionId=at:GenerateGUID(false)self.virtualScripts={}local av=U.sessions;local aw=self.sessionId;local ax=self;av[aw]=ax end;function U:fromSessionId(ay)return self.sessions[ay]end;function U:virtualScriptAdded(az)local aA=self.virtualScripts;aA[#aA+1]=az end;function U:build(d)if d==nil then d=""end;local a0=isfile(self.root..d)or isfolder(self.root..d)local a2="The path '"..self.root..d.."' must be a file or folder"assert(a0,a2)return au(self,self.root..d)end;function U:simulate()local aB={}local a0=#self.virtualScripts>0;assert(a0,"This session cannot start because no LocalScripts were found.")for k,aC in ipairs(self.virtualScripts)do if aC.instance:IsA("LocalScript")then local a1=aC:deferExecutor():andThenReturn(aC.instance)aB[#aB+1]=a1 end end;return a.Promise.all(aB):timeout(10)end;U.sessions=as:getStore("Sessions")end;return{Session=U}end)a.register("out/core/Store.lua","Store",function()local S=a.get("out/core/Store.lua")local aD;if getgenv().RostructStore~=nil then aD=getgenv().RostructStore else local aE=getgenv()aE.RostructStore={}aD=aE.RostructStore end;local aF=aD;local as={getStore=function(self,aG)if aF[aG]~=nil then return aF[aG]end;local aH={}aF[aG]=aH;return aH end}return{Store=as}end)a.register("out/core/VirtualScript.lua","VirtualScript",function()local S=a.get("out/core/VirtualScript.lua")local a=a._G[S]local as=a.import(S,S.Parent,"Store").Store;local at=a.import(S,S.Parent.Parent,"modules","services").HttpService;local w={}local function aI(s)local B=s;local C=0;while B do C=C+1;local aJ=B;B=w[aJ]if s==B then local aK=s:getChunkName()do local aL=0;local aM=false;while true do if aM then aL=aL+1 else aM=true end;if not(aL<C)then break end;local aN=B;B=w[aN]aK=aK.."\n\t\tâ‡’ "..B:getChunkName()end end;error("Requested module '"..(s:getChunkName().."' contains a cyclic reference").."\n\tTraceback: "..aK)end end end;local V;do V=setmetatable({},{__tostring=function()return"VirtualScript"end})V.__index=V;function V.new(...)local self=setmetatable({},V)return self:constructor(...)or self end;function V:constructor(a5,d,Z,aO)if aO==nil then aO=readfile(d)end;self.instance=a5;self.path=d;self.root=Z;self.source=aO;self.id="VirtualScript-"..at:GenerateGUID(false)self.jobComplete=false;self.scriptEnvironment=setmetatable({script=a5,require=function(aP)return V:loadModule(aP,self)end,_PATH=d,_ROOT=Z},{__index=getfenv(0),__metatable="This metatable is locked"})local aQ=V.fromInstance;local ax=self;aQ[a5]=ax end;function V:getFromInstance(aR)return self.fromInstance[aR]end;function V:requireFromInstance(aR)local s=self:getFromInstance(aR)local a2="Failed to get VirtualScript for Instance '"..aR:GetFullName().."'"assert(s,a2)return s:runExecutor()end;function V:loadModule(aR,t)local s=self.fromInstance[aR]if not s then return require(aR)end;w[t]=s;aI(s)local M=s:runExecutor()if w[t]==s then w[t]=nil end;return M end;function V:getChunkName()local aS=self.path;local a0=#self.root+1;local aT=string.sub(aS,a0)return"@"..aT.." ("..self.instance:GetFullName()..")"end;function V:setExecutor(aU)local a0=self.jobComplete==false;assert(a0,"Cannot set executor after script was executed")self.executor=aU end;function V:createExecutor()if self.executor then return self.executor end;local aV,aW=loadstring(self.source,"="..self:getChunkName())assert(aV,aW)self.executor=setfenv(aV,self.scriptEnvironment)return self.executor end;function V:runExecutor()if self.jobComplete then return self.result end;local M=self:createExecutor()(self.scriptEnvironment)if self.instance:IsA("ModuleScript")and M==nil then error("Module '"..self:getChunkName().."' did not return any value")end;self.jobComplete=true;self.result=M;return self.result end;function V:deferExecutor()return a.Promise.defer(function(J)return J(self:runExecutor())end):timeout(30,"Script "..self:getChunkName().." reached execution timeout! Try not to yield the main thread in LocalScripts.")end;V.fromInstance=as:getStore("VirtualScriptStore")end;return{VirtualScript=V}end)a.register("out/core/init.lua","init",function()local S=a.get("out/core/init.lua")local a=a._G[S]local ap={}ap.build=a.import(S,S,"build").build;ap.Store=a.import(S,S,"Store").Store;ap.Session=a.import(S,S,"Session").Session;ap.VirtualScript=a.import(S,S,"VirtualScript").VirtualScript;return ap end)a.register("out/core/types.lua","types",function()local S=a.get("out/core/types.lua")return nil end)a.register("out/core/build/csv.lua","csv",function()local S=a.get("out/core/build/csv.lua")local a=a._G[S]local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local W=a.import(S,S.Parent.Parent.Parent,"utils","file-utils").pathUtils;local aX=a.import(S,S.Parent,"metadata").fileMetadata;local aY={"Context","Example","Key","Source"}local aZ;do aZ=setmetatable({},{__tostring=function()return"CsvReader"end})aZ.__index=aZ;function aZ.new(...)local self=setmetatable({},aZ)return self:constructor(...)or self end;function aZ:constructor(a_,b0)if b0==nil then b0=string.split(a_,"\n")end;self.raw=a_;self.buffer=b0;self.entries={}self.keys={}end;function aZ:read()for aL,b1 in ipairs(self.buffer)do if aL==1 then self:readHeader(b1)else self:readEntry(b1)end end;return self.entries end;function aZ:readHeader(b2)self.keys=string.split(b2,",")end;function aZ:validateEntry(b3)return b3.Context~=nil and(b3.Key~=nil and(b3.Source~=nil and b3.Values~=nil))end;function aZ:readEntry(b2)local b3={Values={}}for aL,P in ipairs(string.split(b2,","))do local n=self.keys[aL-1+1]if table.find(aY,n)~=nil then b3[n]=P else b3.Values[n]=P end end;if self:validateEntry(b3)then local b4=self.entries;b4[#b4+1]=b3 end end end;local function b5(d,h)local b6=aZ.new(readfile(d))local b7=X("LocalizationTable",{Name=h})b7:SetEntries(b6:read())local b8=tostring(W.getParent(d))..h..".meta.json"if isfile(b8)then aX(b8,b7)end;return b7 end;return{makeLocalizationTable=b5}end)a.register("out/core/build/dir.lua","dir",function()local S=a.get("out/core/build/dir.lua")local a=a._G[S]local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local W=a.import(S,S.Parent.Parent.Parent,"utils","file-utils").pathUtils;local b9=a.import(S,S.Parent,"metadata").directoryMetadata;local function ba(d)local b8=d.."init.meta.json"if isfile(b8)then return b9(b8,W.getName(d))end;return X("Folder",{Name=W.getName(d)})end;return{makeDir=ba}end)a.register("out/core/build/init.lua","init",function()local S=a.get("out/core/build/init.lua")local a=a._G[S]local W=a.import(S,S.Parent.Parent,"utils","file-utils").pathUtils;local b5=a.import(S,S,"csv").makeLocalizationTable;local ba=a.import(S,S,"dir").makeDir;local bb=a.import(S,S,"json").makeJsonModule;local bc=a.import(S,S,"json-model").makeJsonModel;local bd=a.import(S,S,"lua")local be=bd.makeLua;local bf=bd.makeLuaInit;local bg=a.import(S,S,"rbx-model").makeRobloxModel;local bh=a.import(S,S,"txt").makePlainText;local function bi(bj,d)if isfolder(d)then local a5;local bk=W.locateFiles(d,{"init.lua","init.server.lua","init.client.lua"})if bk~=nil then a5=bf(bj,d..bk)else a5=ba(d)end;for k,bl in ipairs(listfiles(W.trimTrailingSlash(d)))do local bm=bi(bj,W.addTrailingSlash(bl))if bm then bm.Parent=a5 end end;return a5 elseif isfile(d)then local h=W.getName(d)if string.match(h,"(%.lua)$")~=nil and string.match(h,"^(init%.)")==nil then return be(bj,d)elseif string.match(h,"(%.meta.json)$")~=nil then return nil elseif string.match(h,"(%.model.json)$")~=nil then return bc(d,string.match(h,"^(.*)%.model.json$"))elseif string.match(h,"(%.project.json)$")~=nil then warn("Project files are not supported ("..d..")")elseif string.match(h,"(%.json)$")~=nil then return bb(bj,d,string.match(h,"^(.*)%.json$"))elseif string.match(h,"(%.csv)$")~=nil then return b5(d,string.match(h,"^(.*)%.csv$"))elseif string.match(h,"(%.txt)$")~=nil then return bh(d,string.match(h,"^(.*)%.txt$"))elseif string.match(h,"(%.rbxm)$")~=nil then return bg(bj,d,string.match(h,"^(.*)%.rbxm$"))elseif string.match(h,"(%.rbxmx)$")~=nil then return bg(bj,d,string.match(h,"^(.*)%.rbxmx$"))end end end;return{build=bi}end)a.register("out/core/build/json-model.lua","json-model",function()local S=a.get("out/core/build/json-model.lua")local a=a._G[S]local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local at=a.import(S,S.Parent.Parent.Parent,"modules","services").HttpService;local bn=a.import(S,S.Parent,"EncodedValue")local function bo(bp,d,h)local bq=h;if bq==nil then bq=bp.Name end;local a2="A child in the model file '"..d.."' is missing a Name field"assert(bq~=""and bq,a2)if h~=nil and(bp.Name~=nil and bp.Name~=h)then warn("The name of the model file at '"..d.."' ("..h..") does not match the Name field '"..bp.Name.."'")end;local a0=bp.ClassName~=nil;local a6="An object in the model file '"..d.."' is missing a ClassName field"assert(a0,a6)local aE=bp.ClassName;local u={}local br="Name"local bs=h;if bs==nil then bs=bp.Name end;u[br]=bs;local aP=X(aE,u)if bp.Properties then bn.setModelProperties(aP,bp.Properties)end;if bp.Children then for k,b3 in ipairs(bp.Children)do local bl=bo(b3,d)bl.Parent=aP end end;return aP end;local function bc(d,h)return bo(at:JSONDecode(readfile(d)),d,h)end;return{makeJsonModel=bc}end)a.register("out/core/build/json.lua","json",function()local S=a.get("out/core/build/json.lua")local a=a._G[S]local V=a.import(S,S.Parent.Parent,"VirtualScript").VirtualScript;local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local at=a.import(S,S.Parent.Parent.Parent,"modules","services").HttpService;local W=a.import(S,S.Parent.Parent.Parent,"utils","file-utils").pathUtils;local aX=a.import(S,S.Parent,"metadata").fileMetadata;local function bb(bj,d,h)local a5=X("ModuleScript",{Name=h})local az=V.new(a5,d,bj.root)az:setExecutor(function()return at:JSONDecode(az.source)end)bj:virtualScriptAdded(az)local b8=tostring(W.getParent(d))..h..".meta.json"if isfile(b8)then aX(b8,a5)end;return a5 end;return{makeJsonModule=bb}end)a.register("out/core/build/lua.lua","lua",function()local S=a.get("out/core/build/lua.lua")local a=a._G[S]local V=a.import(S,S.Parent.Parent,"VirtualScript").VirtualScript;local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local bt=a.import(S,S.Parent.Parent.Parent,"utils","replace").replace;local W=a.import(S,S.Parent.Parent.Parent,"utils","file-utils").pathUtils;local aX=a.import(S,S.Parent,"metadata").fileMetadata;local bu={[".server.lua"]="Script",[".client.lua"]="LocalScript",[".lua"]="ModuleScript"}local function be(bj,d,bv)local e=W.getName(d)local bw=bt(e,"(%.client%.lua)$","")or(bt(e,"(%.server%.lua)$","")or(bt(e,"(%.lua)$","")or error("Invalid Lua file at "..d)))local h=bw[1]local bx=bw[2]local aE=bu[bx]local u={}local br="Name"local bq=bv;if bq==nil then bq=h end;u[br]=bq;local a5=X(aE,u)bj:virtualScriptAdded(V.new(a5,d,bj.root))local b8=tostring(W.getParent(d))..h..".meta.json"if isfile(b8)then aX(b8,a5)end;return a5 end;local function bf(bj,d)local by=W.getParent(d)local a5=be(bj,d,W.getName(by))return a5 end;return{makeLua=be,makeLuaInit=bf}end)a.register("out/core/build/metadata.lua","metadata",function()local S=a.get("out/core/build/metadata.lua")local a=a._G[S]local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local at=a.import(S,S.Parent.Parent.Parent,"modules","services").HttpService;local bn=a.import(S,S.Parent,"EncodedValue")local function aX(b8,a5)local bz=at:JSONDecode(readfile(b8))local a0=bz.className==nil;assert(a0,"className can only be specified in init.meta.json files if the parent directory would turn into a Folder!")if bz.properties~=nil then bn.setProperties(a5,bz.properties)end end;local function b9(b8,h)local bz=at:JSONDecode(readfile(b8))local a5=X(bz.className,{Name=h})if bz.properties~=nil then bn.setProperties(a5,bz.properties)end;return a5 end;return{fileMetadata=aX,directoryMetadata=b9}end)a.register("out/core/build/rbx-model.lua","rbx-model",function()local S=a.get("out/core/build/rbx-model.lua")local a=a._G[S]local ao=a.import(S,S.Parent.Parent.Parent,"api").getContentId;local V=a.import(S,S.Parent.Parent,"VirtualScript").VirtualScript;local function bg(bj,d,h)local a2="'"..d.."' could not be loaded; No way to get a content id"assert(ao,a2)local bA=game:GetObjects(ao(d))local a0=#bA==1;local a6="'"..d.."' could not be loaded; Only one top-level instance is supported"assert(a0,a6)local bB=bA[1]bB.Name=h;for k,aP in ipairs(bB:GetDescendants())do if aP:IsA("LuaSourceContainer")then bj:virtualScriptAdded(V.new(aP,d,bj.root,aP.Source))end end;if bB:IsA("LuaSourceContainer")then bj:virtualScriptAdded(V.new(bB,d,bj.root,bB.Source))end;return bB end;return{makeRobloxModel=bg}end)a.register("out/core/build/txt.lua","txt",function()local S=a.get("out/core/build/txt.lua")local a=a._G[S]local X=a.import(S,S.Parent.Parent.Parent,"modules","make")local W=a.import(S,S.Parent.Parent.Parent,"utils","file-utils").pathUtils;local aX=a.import(S,S.Parent,"metadata").fileMetadata;local function bh(d,h)local bC=X("StringValue",{Name=h,Value=readfile(d)})local b8=tostring(W.getParent(d))..h..".meta.json"if isfile(b8)then aX(b8,bC)end;return bC end;return{makePlainText=bh}end)a.register("out/core/build/EncodedValue/init.lua","init",function()local S=a.get("out/core/build/EncodedValue/init.lua")local bD;do local bE=math.floor;local bF=string.char;local function bG(D)local bH={}local bI=0;local bJ="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"local bK=#D;for aL=1,bK-2,3 do local bL,bM,bN=D:byte(aL,aL+3)local bO=bN+bM*256+bL*256*256;local bP=bO%64+1;bO=bE(bO/64)local bQ=bO%64+1;bO=bE(bO/64)local bR=bO%64+1;bO=bE(bO/64)local bS=bO%64+1;bH[bI+1]=bJ:sub(bS,bS)bH[bI+2]=bJ:sub(bR,bR)bH[bI+3]=bJ:sub(bQ,bQ)bH[bI+4]=bJ:sub(bP,bP)bI=bI+4 end;local bT=bK%3;if bT==2 then local bL,bM=D:byte(-2,-1)local bO=bM*4+bL*4*256;local bQ=bO%64+1;bO=bE(bO/64)local bR=bO%64+1;bO=bE(bO/64)local bS=bO%64+1;bH[bI+1]=bJ:sub(bS,bS)bH[bI+2]=bJ:sub(bR,bR)bH[bI+3]=bJ:sub(bQ,bQ)bH[bI+4]="="elseif bT==1 then local bL=D:byte(-1,-1)local bO=bL*16;local bR=bO%64+1;bO=bE(bO/64)local bS=bO%64+1;bH[bI+1]=bJ:sub(bS,bS)bH[bI+2]=bJ:sub(bR,bR)bH[bI+3]="="bH[bI+4]="="end;return table.concat(bH,"")end;local function bU(D)local bH={}local bI=0;local bJ="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"local bK=#D;local bV=0;local bW=0;local bX={}for aL=1,#bJ do bX[bJ:sub(aL,aL)]=aL-1 end;for aL=1,bK do local bY=D:sub(aL,aL)local bZ=bX[bY]if bZ then bV=bV*64+bZ;bW=bW+1 end;if bW==4 then local bN=bV%256;bV=bE(bV/256)local bM=bV%256;bV=bE(bV/256)local bL=bV%256;bH[bI+1]=bF(bL)bH[bI+2]=bF(bM)bH[bI+3]=bF(bN)bI=bI+3;bW=0;bV=0 end end;if bW==3 then bV=bV*64;bV=bE(bV/256)local bM=bV%256;bV=bE(bV/256)local bL=bV%256;bH[bI+1]=bF(bL)bH[bI+2]=bF(bM)elseif bW==2 then bV=bV*64;bV=bE(bV/256)bV=bV*64;bV=bE(bV/256)local bL=bV%256;bH[bI+1]=bF(bL)elseif bW==1 then error("Base64 has invalid length")end;return table.concat(bH,"")end;bD={decode=bU,encode=bG}end;local function b_(...)return...end;local function c0(aV)return function(P)return aV(unpack(P))end end;local function c1(P)if P==math.huge or P==-math.huge then return 999999999*math.sign(P)end;return P end;local c2={"X","Y","Z"}local c3={"Right","Top","Back","Left","Bottom","Front"}local c4;c4={boolean={fromPod=b_,toPod=b_},number={fromPod=b_,toPod=b_},string={fromPod=b_,toPod=b_},EnumItem={fromPod=b_,toPod=function(c5)if typeof(c5)=="number"then return c5 else return c5.Value end end},Axes={fromPod=function(c6)local c7={}for c8,c9 in ipairs(c6)do c7[c8]=Enum.Axis[c9]end;return Axes.new(unpack(c7))end,toPod=function(c5)local ca={}for k,cb in ipairs(c2)do if c5[cb]then table.insert(ca,cb)end end;return ca end},BinaryString={fromPod=bD.decode,toPod=bD.encode},Bool={fromPod=b_,toPod=b_},BrickColor={fromPod=function(c6)return BrickColor.new(c6)end,toPod=function(c5)return c5.Number end},CFrame={fromPod=function(c6)local cc=c6.Position;local cd=c6.Orientation;return CFrame.new(cc[1],cc[2],cc[3],cd[1][1],cd[1][2],cd[1][3],cd[2][1],cd[2][2],cd[2][3],cd[3][1],cd[3][2],cd[3][3])end,toPod=function(c5)local ce,cf,cg,ch,ci,cj,ck,cl,cm,cn,co,cp=c5:GetComponents()return{Position={ce,cf,cg},Orientation={{ch,ci,cj},{ck,cl,cm},{cn,co,cp}}}end},Color3={fromPod=c0(Color3.new),toPod=function(c5)return{c5.r,c5.g,c5.b}end},Color3uint8={fromPod=c0(Color3.fromRGB),toPod=function(c5)return{math.round(c5.R*255),math.round(c5.G*255),math.round(c5.B*255)}end},ColorSequence={fromPod=function(c6)local cq={}for c8,cr in ipairs(c6.Keypoints)do cq[c8]=ColorSequenceKeypoint.new(cr.Time,c4.Color3.fromPod(cr.Color))end;return ColorSequence.new(cq)end,toPod=function(c5)local cq={}for c8,cr in ipairs(c5.Keypoints)do cq[c8]={Time=cr.Time,Color=c4.Color3.toPod(cr.Value)}end;return{Keypoints=cq}end},Content={fromPod=b_,toPod=b_},Faces={fromPod=function(c6)local cs={}for c8,ct in ipairs(c6)do cs[c8]=Enum.NormalId[ct]end;return Faces.new(unpack(cs))end,toPod=function(c5)local c6={}for k,cu in ipairs(c3)do if c5[cu]then table.insert(c6,cu)end end;return c6 end},Float32={fromPod=b_,toPod=c1},Float64={fromPod=b_,toPod=c1},Int32={fromPod=b_,toPod=b_},Int64={fromPod=b_,toPod=b_},NumberRange={fromPod=c0(NumberRange.new),toPod=function(c5)return{c5.Min,c5.Max}end},NumberSequence={fromPod=function(c6)local cq={}for c8,cr in ipairs(c6.Keypoints)do cq[c8]=NumberSequenceKeypoint.new(cr.Time,cr.Value,cr.Envelope)end;return NumberSequence.new(cq)end,toPod=function(c5)local cq={}for c8,cr in ipairs(c5.Keypoints)do cq[c8]={Time=cr.Time,Value=cr.Value,Envelope=cr.Envelope}end;return{Keypoints=cq}end},PhysicalProperties={fromPod=function(c6)if c6=="Default"then return nil else return PhysicalProperties.new(c6.Density,c6.Friction,c6.Elasticity,c6.FrictionWeight,c6.ElasticityWeight)end end,toPod=function(c5)if c5==nil then return"Default"else return{Density=c5.Density,Friction=c5.Friction,Elasticity=c5.Elasticity,FrictionWeight=c5.FrictionWeight,ElasticityWeight=c5.ElasticityWeight}end end},Ray={fromPod=function(c6)return Ray.new(c4.Vector3.fromPod(c6.Origin),c4.Vector3.fromPod(c6.Direction))end,toPod=function(c5)return{Origin=c4.Vector3.toPod(c5.Origin),Direction=c4.Vector3.toPod(c5.Direction)}end},Rect={fromPod=function(c6)return Rect.new(c4.Vector2.fromPod(c6[1]),c4.Vector2.fromPod(c6[2]))end,toPod=function(c5)return{c4.Vector2.toPod(c5.Min),c4.Vector2.toPod(c5.Max)}end},Instance={fromPod=function(cv)error("Ref cannot be decoded on its own")end,toPod=function(cw)error("Ref can not be encoded on its own")end},Ref={fromPod=function(cv)error("Ref cannot be decoded on its own")end,toPod=function(cw)error("Ref can not be encoded on its own")end},Region3={fromPod=function(c6)error("Region3 is not implemented")end,toPod=function(c5)error("Region3 is not implemented")end},Region3int16={fromPod=function(c6)return Region3int16.new(c4.Vector3int16.fromPod(c6[1]),c4.Vector3int16.fromPod(c6[2]))end,toPod=function(c5)return{c4.Vector3int16.toPod(c5.Min),c4.Vector3int16.toPod(c5.Max)}end},SharedString={fromPod=function(c6)error("SharedString is not supported")end,toPod=function(c5)error("SharedString is not supported")end},String={fromPod=b_,toPod=b_},UDim={fromPod=c0(UDim.new),toPod=function(c5)return{c5.Scale,c5.Offset}end},UDim2={fromPod=function(c6)return UDim2.new(c4.UDim.fromPod(c6[1]),c4.UDim.fromPod(c6[2]))end,toPod=function(c5)return{c4.UDim.toPod(c5.X),c4.UDim.toPod(c5.Y)}end},Vector2={fromPod=c0(Vector2.new),toPod=function(c5)return{c1(c5.X),c1(c5.Y)}end},Vector2int16={fromPod=c0(Vector2int16.new),toPod=function(c5)return{c5.X,c5.Y}end},Vector3={fromPod=c0(Vector3.new),toPod=function(c5)return{c1(c5.X),c1(c5.Y),c1(c5.Z)}end},Vector3int16={fromPod=c0(Vector3int16.new),toPod=function(c5)return{c5.X,c5.Y,c5.Z}end}}local bn={}function bn.decode(cx,cy)local cz=c4[cx]if cz==nil then return false,"Couldn't decode value "..tostring(cx)end;return true,cz.fromPod(cy)end;function bn.setProperty(aP,a7,cy,cx)cx=cx or typeof(aP[a7])local Q,M=bn.decode(cx,cy)if Q then aP[a7]=M else warn("Could not set property "..a7 .." of "..aP.GetFullName().."; "..M)end end;function bn.setProperties(aP,cA)for a7,cy in pairs(cA)do bn.setProperty(aP,a7,cy)end end;function bn.setModelProperties(aP,cA)for a7,cy in pairs(cA)do bn.setProperty(aP,a7,cy.Value,cy.Type)end end;return bn end)a.register("out/modules/Promise/init.lua","init",function()local S=a.get("out/modules/Promise/init.lua")local cB="Non-promise value passed into %s at index %s"local cC="Please pass a list of promises to %s"local cD="Please pass a handler function to %s!"local cE={__mode="k"}local function cF(cG,cH)local cI={}for k,cJ in ipairs(cH)do cI[cJ]=cJ end;return setmetatable(cI,{__index=function(k,b)error(string.format("%s is not in %s!",b,cG),2)end,__newindex=function()error(string.format("Creating new members in %s is not allowed!",cG),2)end})end;local cK;do cK={Kind=cF("Promise.Error.Kind",{"ExecutionError","AlreadyCancelled","NotResolvedInTime","TimedOut"})}cK.__index=cK;function cK.new(cL,cM)cL=cL or{}return setmetatable({error=tostring(cL.error)or"[This error has no error text.]",trace=cL.trace,context=cL.context,kind=cL.kind,parent=cM,createdTick=os.clock(),createdTrace=debug.traceback()},cK)end;function cK.is(cN)if type(cN)=="table"then local cO=getmetatable(cN)if type(cO)=="table"then return rawget(cN,"error")~=nil and type(rawget(cO,"extend"))=="function"end end;return false end;function cK.isKind(cN,cP)assert(cP~=nil,"Argument #2 to Promise.Error.isKind must not be nil")return cK.is(cN)and cN.kind==cP end;function cK:extend(cL)cL=cL or{}cL.kind=cL.kind or self.kind;return cK.new(cL,self)end;function cK:getErrorChain()local cQ={self}while cQ[#cQ].parent do table.insert(cQ,cQ[#cQ].parent)end;return cQ end;function cK:__tostring()local cR={string.format("-- Promise.Error(%s) --",self.kind or"?")}for k,cS in ipairs(self:getErrorChain())do table.insert(cR,table.concat({cS.trace or cS.error,cS.context},"\n"))end;return table.concat(cR,"\n")end end;local function cT(...)return select("#",...),{...}end;local function cU(Q,...)return Q,select("#",...),{...}end;local function cV(aK)assert(aK~=nil)return function(aW)if type(aW)=="table"then return aW end;return cK.new({error=aW,kind=cK.Kind.ExecutionError,trace=debug.traceback(tostring(aW),2),context="Promise created at:\n\n"..aK})end end;local function cW(aK,F,...)return cU(xpcall(F,cV(aK),...))end;local function cX(aK,F,J,K)return function(...)local L,cY,M=cW(aK,F,...)if L then J(unpack(M,1,cY))else K(M[1])end end end;local function cZ(c_)return next(c_)==nil end;local G={Error=cK,Status=cF("Promise.Status",{"Started","Resolved","Rejected","Cancelled"}),_getTime=os.clock,_timeEvent=game:GetService("RunService").Heartbeat}G.prototype={}G.__index=G.prototype;function G._new(aK,F,cM)if cM~=nil and not G.is(cM)then error("Argument #2 to Promise.new must be a promise or nil",2)end;local self={_source=aK,_status=G.Status.Started,_values=nil,_valuesLength=-1,_unhandledRejection=true,_queuedResolve={},_queuedReject={},_queuedFinally={},_cancellationHook=nil,_parent=cM,_consumers=setmetatable({},cE)}if cM and cM._status==G.Status.Started then cM._consumers[self]=true end;setmetatable(self,G)local function J(...)self:_resolve(...)end;local function K(...)self:_reject(...)end;local function d0(d1)if d1 then if self._status==G.Status.Cancelled then d1()else self._cancellationHook=d1 end end;return self._status==G.Status.Cancelled end;coroutine.wrap(function()local L,k,M=cW(self._source,F,J,K,d0)if not L then K(M[1])end end)()return self end;function G.new(d2)return G._new(debug.traceback(nil,2),d2)end;function G:__tostring()return string.format("Promise(%s)",self:getStatus())end;function G.defer(F)local aK=debug.traceback(nil,2)local N;N=G._new(aK,function(J,K,d0)local d3;d3=G._timeEvent:Connect(function()d3:Disconnect()local L,k,M=cW(aK,F,J,K,d0)if not L then K(M[1])end end)end)return N end;G.async=G.defer;function G.resolve(...)local d4,d5=cT(...)return G._new(debug.traceback(nil,2),function(J)J(unpack(d5,1,d4))end)end;function G.reject(...)local d4,d5=cT(...)return G._new(debug.traceback(nil,2),function(k,K)K(unpack(d5,1,d4))end)end;function G._try(aK,F,...)local d6,d5=cT(...)return G._new(aK,function(J)J(F(unpack(d5,1,d6)))end)end;function G.try(...)return G._try(debug.traceback(nil,2),...)end;function G._all(aK,d7,d8)if type(d7)~="table"then error(string.format(cC,"Promise.all"),3)end;for aL,N in pairs(d7)do if not G.is(N)then error(string.format(cB,"Promise.all",tostring(aL)),3)end end;if#d7==0 or d8==0 then return G.resolve({})end;return G._new(aK,function(J,K,d0)local d9={}local da={}local db=0;local dc=0;local dd=false;local function de()for k,N in ipairs(da)do N:cancel()end end;local function df(aL,...)if dd then return end;db=db+1;if d8==nil then d9[aL]=...else d9[db]=...end;if db>=(d8 or#d7)then dd=true;J(d9)de()end end;d0(de)for aL,N in ipairs(d7)do da[aL]=N:andThen(function(...)df(aL,...)end,function(...)dc=dc+1;if d8==nil or#d7-dc<d8 then de()dd=true;K(...)end end)end;if dd then de()end end)end;function G.all(d7)return G._all(debug.traceback(nil,2),d7)end;function G.fold(dg,F,dh)assert(type(dg)=="table","Bad argument #1 to Promise.fold: must be a table")assert(type(F)=="function","Bad argument #2 to Promise.fold: must be a function")local di=G.resolve(dh)return G.each(dg,function(dj,aL)di=di:andThen(function(dk)return F(dk,dj,aL)end)end):andThenReturn(di)end;function G.some(d7,d8)assert(type(d8)=="number","Bad argument #2 to Promise.some: must be a number")return G._all(debug.traceback(nil,2),d7,d8)end;function G.any(d7)return G._all(debug.traceback(nil,2),d7,1):andThen(function(d5)return d5[1]end)end;function G.allSettled(d7)if type(d7)~="table"then error(string.format(cC,"Promise.allSettled"),2)end;for aL,N in pairs(d7)do if not G.is(N)then error(string.format(cB,"Promise.allSettled",tostring(aL)),2)end end;if#d7==0 then return G.resolve({})end;return G._new(debug.traceback(nil,2),function(J,k,d0)local dl={}local da={}local dm=0;local function df(aL,...)dm=dm+1;dl[aL]=...if dm>=#d7 then J(dl)end end;d0(function()for k,N in ipairs(da)do N:cancel()end end)for aL,N in ipairs(d7)do da[aL]=N:finally(function(...)df(aL,...)end)end end)end;function G.race(d7)assert(type(d7)=="table",string.format(cC,"Promise.race"))for aL,N in pairs(d7)do assert(G.is(N),string.format(cB,"Promise.race",tostring(aL)))end;return G._new(debug.traceback(nil,2),function(J,K,d0)local da={}local dn=false;local function de()for k,N in ipairs(da)do N:cancel()end end;local function dp(F)return function(...)de()dn=true;return F(...)end end;if d0(dp(K))then return end;for aL,N in ipairs(d7)do da[aL]=N:andThen(dp(J),dp(K))end;if dn then de()end end)end;function G.each(dg,dq)assert(type(dg)=="table",string.format(cC,"Promise.each"))assert(type(dq)=="function",string.format(cD,"Promise.each"))return G._new(debug.traceback(nil,2),function(J,K,d0)local dr={}local ds={}local dt=false;local function de()for k,du in ipairs(ds)do du:cancel()end end;d0(function()dt=true;de()end)local dv={}for c8,P in ipairs(dg)do if G.is(P)then if P:getStatus()==G.Status.Cancelled then de()return K(cK.new({error="Promise is cancelled",kind=cK.Kind.AlreadyCancelled,context=string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",c8,P._source)}))elseif P:getStatus()==G.Status.Rejected then de()return K(select(2,P:await()))end;local dw=P:andThen(function(...)return...end)table.insert(ds,dw)dv[c8]=dw else dv[c8]=P end end;for c8,P in ipairs(dv)do if G.is(P)then local Q;Q,P=P:await()if not Q then de()return K(P)end end;if dt then return end;local dx=G.resolve(dq(P,c8))table.insert(ds,dx)local Q,M=dx:await()if not Q then de()return K(M)end;dr[c8]=M end;J(dr)end)end;function G.is(aR)if type(aR)~="table"then return false end;local dy=getmetatable(aR)if dy==G then return true elseif dy==nil then return type(aR.andThen)=="function"elseif type(dy)=="table"and type(rawget(dy,"__index"))=="table"and type(rawget(rawget(dy,"__index"),"andThen"))=="function"then return true end;return false end;function G.promisify(F)return function(...)return G._try(debug.traceback(nil,2),F,...)end end;do local dz;local d3;function G.delay(dA)assert(type(dA)=="number","Bad argument #1 to Promise.delay, must be a number.")if not(dA>=1/60)or dA==math.huge then dA=1/60 end;return G._new(debug.traceback(nil,2),function(J,k,d0)local dB=G._getTime()local dC=dB+dA;local dD={resolve=J,startTime=dB,endTime=dC}if d3==nil then dz=dD;d3=G._timeEvent:Connect(function()local dE=G._getTime()while dz~=nil and dz.endTime<dE do local dF=dz;dz=dF.next;if dz==nil then d3:Disconnect()d3=nil else dz.previous=nil end;dF.resolve(G._getTime()-dF.startTime)end end)else if dz.endTime<dC then local dF=dz;local next=dF.next;while next~=nil and next.endTime<dC do dF=next;next=dF.next end;dF.next=dD;dD.previous=dF;if next~=nil then dD.next=next;next.previous=dD end else dD.next=dz;dz.previous=dD;dz=dD end end;d0(function()local next=dD.next;if dz==dD then if next==nil then d3:Disconnect()d3=nil else next.previous=nil end;dz=next else local dG=dD.previous;dG.next=next;if next~=nil then next.previous=dG end end end)end)end end;function G.prototype:timeout(dA,dH)local aK=debug.traceback(nil,2)return G.race({G.delay(dA):andThen(function()return G.reject(dH==nil and cK.new({kind=cK.Kind.TimedOut,error="Timed out",context=string.format("Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",dA,aK)})or dH)end),self})end;function G.prototype:getStatus()return self._status end;function G.prototype:_andThen(aK,dI,dJ)self._unhandledRejection=false;return G._new(aK,function(J,K)local dK=J;if dI then dK=cX(aK,dI,J,K)end;local dL=K;if dJ then dL=cX(aK,dJ,J,K)end;if self._status==G.Status.Started then table.insert(self._queuedResolve,dK)table.insert(self._queuedReject,dL)elseif self._status==G.Status.Resolved then dK(unpack(self._values,1,self._valuesLength))elseif self._status==G.Status.Rejected then dL(unpack(self._values,1,self._valuesLength))elseif self._status==G.Status.Cancelled then K(cK.new({error="Promise is cancelled",kind=cK.Kind.AlreadyCancelled,context="Promise created at\n\n"..aK}))end end,self)end;function G.prototype:andThen(dI,dJ)assert(dI==nil or type(dI)=="function",string.format(cD,"Promise:andThen"))assert(dJ==nil or type(dJ)=="function",string.format(cD,"Promise:andThen"))return self:_andThen(debug.traceback(nil,2),dI,dJ)end;function G.prototype:catch(dL)assert(dL==nil or type(dL)=="function",string.format(cD,"Promise:catch"))return self:_andThen(debug.traceback(nil,2),nil,dL)end;function G.prototype:tap(dM)assert(type(dM)=="function",string.format(cD,"Promise:tap"))return self:_andThen(debug.traceback(nil,2),function(...)local dN=dM(...)if G.is(dN)then local d4,d5=cT(...)return dN:andThen(function()return unpack(d5,1,d4)end)end;return...end)end;function G.prototype:andThenCall(F,...)assert(type(F)=="function",string.format(cD,"Promise:andThenCall"))local d4,d5=cT(...)return self:_andThen(debug.traceback(nil,2),function()return F(unpack(d5,1,d4))end)end;function G.prototype:andThenReturn(...)local d4,d5=cT(...)return self:_andThen(debug.traceback(nil,2),function()return unpack(d5,1,d4)end)end;function G.prototype:cancel()if self._status~=G.Status.Started then return end;self._status=G.Status.Cancelled;if self._cancellationHook then self._cancellationHook()end;if self._parent then self._parent:_consumerCancelled(self)end;for bl in pairs(self._consumers)do bl:cancel()end;self:_finalize()end;function G.prototype:_consumerCancelled(dO)if self._status~=G.Status.Started then return end;self._consumers[dO]=nil;if next(self._consumers)==nil then self:cancel()end end;function G.prototype:_finally(aK,dP,dQ)if not dQ then self._unhandledRejection=false end;return G._new(aK,function(J,K)local dR=J;if dP then dR=cX(aK,dP,J,K)end;if dQ then local F=dR;dR=function(...)if self._status==G.Status.Rejected then return J(self)end;return F(...)end end;if self._status==G.Status.Started then table.insert(self._queuedFinally,dR)else dR(self._status)end end,self)end;function G.prototype:finally(dP)assert(dP==nil or type(dP)=="function",string.format(cD,"Promise:finally"))return self:_finally(debug.traceback(nil,2),dP)end;function G.prototype:finallyCall(F,...)assert(type(F)=="function",string.format(cD,"Promise:finallyCall"))local d4,d5=cT(...)return self:_finally(debug.traceback(nil,2),function()return F(unpack(d5,1,d4))end)end;function G.prototype:finallyReturn(...)local d4,d5=cT(...)return self:_finally(debug.traceback(nil,2),function()return unpack(d5,1,d4)end)end;function G.prototype:done(dP)assert(dP==nil or type(dP)=="function",string.format(cD,"Promise:done"))return self:_finally(debug.traceback(nil,2),dP,true)end;function G.prototype:doneCall(F,...)assert(type(F)=="function",string.format(cD,"Promise:doneCall"))local d4,d5=cT(...)return self:_finally(debug.traceback(nil,2),function()return F(unpack(d5,1,d4))end,true)end;function G.prototype:doneReturn(...)local d4,d5=cT(...)return self:_finally(debug.traceback(nil,2),function()return unpack(d5,1,d4)end,true)end;function G.prototype:awaitStatus()self._unhandledRejection=false;if self._status==G.Status.Started then local dS=Instance.new("BindableEvent")self:finally(function()dS:Fire()end)dS.Event:Wait()dS:Destroy()end;if self._status==G.Status.Resolved then return self._status,unpack(self._values,1,self._valuesLength)elseif self._status==G.Status.Rejected then return self._status,unpack(self._values,1,self._valuesLength)end;return self._status end;local function dT(O,...)return O==G.Status.Resolved,...end;function G.prototype:await()return dT(self:awaitStatus())end;local function dU(O,...)if O~=G.Status.Resolved then error(...==nil and"Expected Promise rejected with no value."or...,3)end;return...end;function G.prototype:expect()return dU(self:awaitStatus())end;G.prototype.awaitValue=G.prototype.expect;function G.prototype:_unwrap()if self._status==G.Status.Started then error("Promise has not resolved or rejected.",2)end;local Q=self._status==G.Status.Resolved;return Q,unpack(self._values,1,self._valuesLength)end;function G.prototype:_resolve(...)if self._status~=G.Status.Started then if G.is(...)then select(1,...):_consumerCancelled(self)end;return end;if G.is(...)then if select("#",...)>1 then local dV=string.format("When returning a Promise from andThen, extra arguments are ".."discarded! See:\n\n%s",self._source)warn(dV)end;local dW=...local N=dW:andThen(function(...)self:_resolve(...)end,function(...)local dX=dW._values[1]if dW._error then dX=cK.new({error=dW._error,kind=cK.Kind.ExecutionError,context="[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]"})end;if cK.isKind(dX,cK.Kind.ExecutionError)then return self:_reject(dX:extend({error="This Promise was chained to a Promise that errored.",trace="",context=string.format("The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",self._source)}))end;self:_reject(...)end)if N._status==G.Status.Cancelled then self:cancel()elseif N._status==G.Status.Started then self._parent=N;N._consumers[self]=true end;return end;self._status=G.Status.Resolved;self._valuesLength,self._values=cT(...)for k,F in ipairs(self._queuedResolve)do coroutine.wrap(F)(...)end;self:_finalize()end;function G.prototype:_reject(...)if self._status~=G.Status.Started then return end;self._status=G.Status.Rejected;self._valuesLength,self._values=cT(...)if not cZ(self._queuedReject)then for k,F in ipairs(self._queuedReject)do coroutine.wrap(F)(...)end else local aW=tostring(...)coroutine.wrap(function()G._timeEvent:Wait()if not self._unhandledRejection then return end;local dV=string.format("Unhandled Promise rejection:\n\n%s\n\n%s",aW,self._source)if G.TEST then return end;warn(dV)end)()end;self:_finalize()end;function G.prototype:_finalize()for k,F in ipairs(self._queuedFinally)do coroutine.wrap(F)(self._status)end;self._queuedFinally=nil;self._queuedReject=nil;self._queuedResolve=nil;if not G.TEST then self._parent=nil;self._consumers=nil end end;function G.prototype:now(dH)local aK=debug.traceback(nil,2)if self:getStatus()==G.Status.Resolved then return self:_andThen(aK,function(...)return...end)else return G.reject(dH==nil and cK.new({kind=cK.Kind.NotResolvedInTime,error="This Promise was not resolved in time for :now()",context=":now() was called at:\n\n"..aK})or dH)end end;function G.retry(F,dY,...)assert(type(F)=="function","Parameter #1 to Promise.retry must be a function")assert(type(dY)=="number","Parameter #2 to Promise.retry must be a number")local I,d4={...},select("#",...)return G.resolve(F(...)):catch(function(...)if dY>0 then return G.retry(F,dY-1,unpack(I,1,d4))else return G.reject(...)end end)end;function G.fromEvent(dZ,dq)dq=dq or function()return true end;return G._new(debug.traceback(nil,2),function(J,K,d0)local d3;local d_=false;local function e0()d3:Disconnect()d3=nil end;d3=dZ:Connect(function(...)local e1=dq(...)if e1==true then J(...)if d3 then e0()else d_=true end elseif type(e1)~="boolean"then error("Promise.fromEvent predicate should always return a boolean")end end)if d_ and d3 then return e0()end;d0(function()e0()end)end)end;return G end)a.register("out/modules/make/init.lua","init",function()local S=a.get("out/modules/make/init.lua")local function X(e2,e3)local e4=e3;local e5=e4.Children;local cM=e4.Parent;local a5=Instance.new(e2)for e6,P in pairs(e3)do if e6~="Children"and e6~="Parent"then local e7=a5;local e8=e7[e6]local e9=e8;if typeof(e9)=="RBXScriptSignal"then e8:Connect(P)else a5[e6]=P end end end;if e5 then for k,bl in ipairs(e5)do bl.Parent=a5 end end;a5.Parent=cM;return a5 end;return X end)a.register("out/modules/object-utils/init.lua","init",function()local S=a.get("out/modules/object-utils/init.lua")local at=game:GetService("HttpService")local ea={}function ea.keys(aR)local M=table.create(#aR)for n in pairs(aR)do M[#M+1]=n end;return M end;function ea.values(aR)local M=table.create(#aR)for k,P in pairs(aR)do M[#M+1]=P end;return M end;function ea.entries(aR)local M=table.create(#aR)for n,P in pairs(aR)do M[#M+1]={n,P}end;return M end;function ea.assign(eb,...)for aL=1,select("#",...)do local ec=select(aL,...)if type(ec)=="table"then for n,P in pairs(ec)do eb[n]=P end end end;return eb end;function ea.copy(aR)local M=table.create(#aR)for b,aC in pairs(aR)do M[b]=aC end;return M end;local function ed(aR,ee)local M=table.create(#aR)ee[aR]=M;for b,aC in pairs(aR)do if type(b)=="table"then b=ee[b]or ed(b,ee)end;if type(aC)=="table"then aC=ee[aC]or ed(aC,ee)end;M[b]=aC end;return M end;function ea.deepCopy(aR)return ed(aR,{})end;function ea.deepEquals(ef,eg)for b in pairs(ef)do local eh=ef[b]local ei=eg[b]if type(eh)=="table"and type(ei)=="table"then local M=ea.deepEquals(eh,ei)if not M then return false end elseif eh~=ei then return false end end;for b in pairs(eg)do if ef[b]==nil then return false end end;return true end;function ea.toString(E)return at:JSONEncode(E)end;function ea.isEmpty(aR)return next(aR)==nil end;function ea.fromEntries(ej)local ek=#ej;local M=table.create(ek)if ej then for aL=1,ek do local el=ej[aL]M[el[1]]=el[2]end end;return M end;return ea end)a.register("out/modules/services/init.lua","init",function()local S=a.get("out/modules/services/init.lua")return setmetatable({},{__index=function(self,em)local en=game:GetService(em)self[em]=en;return en end})end)a.register("out/modules/zzlib/init.lua","init",function()local S=a.get("out/modules/zzlib/init.lua")local unpack=unpack;local M;local eo;do local ep={}local eq=bit32;ep.band=eq.band;ep.rshift=eq.rshift;function ep.bitstream_init(aT)local er={file=aT,buf=nil,len=nil,pos=1,b=0,n=0}function er:flushb(H)self.n=self.n-H;self.b=eq.rshift(self.b,H)end;function er:peekb(H)while self.n<H do if self.pos>self.len then self.buf=self.file:read(4096)self.len=self.buf:len()self.pos=1 end;self.b=self.b+eq.lshift(self.buf:byte(self.pos),self.n)self.pos=self.pos+1;self.n=self.n+8 end;return eq.band(self.b,eq.lshift(1,H)-1)end;function er:getb(H)local es=er:peekb(H)self.n=self.n-H;self.b=eq.rshift(self.b,H)return es end;function er:getv(et,H)local eu=et[er:peekb(H)]local ev=eq.band(eu,15)local es=eq.rshift(eu,4)self.n=self.n-ev;self.b=eq.rshift(self.b,ev)return es end;function er:close()if self.file then self.file:close()end end;if type(aT)=="string"then er.file=nil;er.buf=aT else er.buf=aT:read(4096)end;er.len=er.buf:len()return er end;local function ew(ex)local ey=#ex;local ez=1;local eA={}local eB={}for aL=1,ey do local eC=ex[aL]if eC>ez then ez=eC end;eA[eC]=(eA[eC]or 0)+1 end;local table={}local eD=0;eA[0]=0;for aL=1,ez do eD=(eD+(eA[aL-1]or 0))*2;eB[aL]=eD end;for aL=1,ey do local ev=ex[aL]or 0;if ev>0 then local eu=(aL-1)*16+ev;local eD=eB[ev]local eE=0;for eF=1,ev do eE=eE+eq.lshift(eq.band(1,eq.rshift(eD,eF-1)),ev-eF)end;for eF=0,2^ez-1,2^ev do table[eF+eE]=eu end;eB[ev]=eB[ev]+1 end end;return table,ez end;local function eG(bH,er,eH,eI,eJ,eK)local eL;repeat eL=er:getv(eJ,eH)if eL<256 then table.insert(bH,eL)elseif eL>256 then local ez=0;local eM=3;local eN=1;if eL<265 then eM=eM+eL-257 elseif eL<285 then ez=eq.rshift(eL-261,2)eM=eM+eq.lshift(eq.band(eL-261,3)+4,ez)else eM=258 end;if ez>0 then eM=eM+er:getb(ez)end;local aC=er:getv(eK,eI)if aC<4 then eN=eN+aC else ez=eq.rshift(aC-2,1)eN=eN+eq.lshift(eq.band(aC,1)+2,ez)eN=eN+er:getb(ez)end;local eO=#bH-eN+1;while eM>0 do table.insert(bH,bH[eO])eO=eO+1;eM=eM-1 end end until eL==256 end;local function eP(bH,er)local eQ={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local eR=257+er:getb(5)local eS=1+er:getb(5)local eT=4+er:getb(4)local ex={}for aL=1,eT do local aC=er:getb(3)ex[eQ[aL]]=aC end;for aL=eT+1,19 do ex[eQ[aL]]=0 end;local eU,eV=ew(ex)local aL=1;while aL<=eR+eS do local aC=er:getv(eU,eV)if aC<16 then ex[aL]=aC;aL=aL+1 elseif aC<19 then local eW={2,3,7}local eX=eW[aC-15]local eY=0;local H=3+er:getb(eX)if aC==16 then eY=ex[aL-1]elseif aC==18 then H=H+8 end;for eF=1,H do ex[aL]=eY;aL=aL+1 end else error("wrong entry in depth table for literal/length alphabet: "..aC)end end;local eZ={}for aL=1,eR do table.insert(eZ,ex[aL])end;local eJ,eH=ew(eZ)local e_={}for aL=eR+1,#ex do table.insert(e_,ex[aL])end;local eK,eI=ew(e_)eG(bH,er,eH,eI,eJ,eK)end;local function f0(bH,er)local f1={144,112,24,8}local f2={8,9,7,8}local ex={}for aL=1,4 do local eC=f2[aL]for eF=1,f1[aL]do table.insert(ex,eC)end end;local eJ,eH=ew(ex)ex={}for aL=1,32 do ex[aL]=5 end;local eK,eI=ew(ex)eG(bH,er,eH,eI,eJ,eK)end;local function f3(bH,er)er:flushb(eq.band(er.n,7))local ev=er:getb(16)if er.n>0 then error("Unexpected.. should be zero remaining bits in buffer.")end;local eV=er:getb(16)if eq.bxor(ev,eV)~=65535 then error("LEN and NLEN don't match")end;for aL=er.pos,er.pos+ev-1 do table.insert(bH,er.buf:byte(aL,aL))end;er.pos=er.pos+ev end;function ep.main(er)local f4,type;local f5={}repeat local f6;f4=er:getb(1)type=er:getb(2)if type==0 then f3(f5,er)elseif type==1 then f0(f5,er)elseif type==2 then eP(f5,er)else error("unsupported block type")end until f4==1;er:flushb(eq.band(er.n,7))return f5 end;local f7;function ep.crc32(f8,f9)if not f7 then f7={}for aL=0,255 do local fa=aL;for eF=1,8 do fa=eq.bxor(eq.rshift(fa,1),eq.band(0xedb88320,eq.bnot(eq.band(fa,1)-1)))end;f7[aL]=fa end end;f9=eq.bnot(f9 or 0)for aL=1,#f8 do local eY=f8:byte(aL)f9=eq.bxor(f7[eq.bxor(eY,eq.band(f9,0xff))],eq.rshift(f9,8))end;f9=eq.bnot(f9)if f9<0 then f9=f9+4294967296 end;return f9 end;eo=ep end;local fb={}local function fc(fd)local fe={}local eM=#fd;local cc=1;local ff=1;while eM>0 do local fg=eM>=2048 and 2048 or eM;local f8=string.char(unpack(fd,cc,cc+fg-1))cc=cc+fg;eM=eM-fg;local aL=1;while fe[aL]do f8=fe[aL]..f8;fe[aL]=nil;aL=aL+1 end;if aL>ff then ff=aL end;fe[aL]=f8 end;local D=""for aL=1,ff do if fe[aL]then D=fe[aL]..D end end;return D end;local function fh(er)local fi,fj,fk,fl=er.buf:byte(1,4)if fi~=31 or fj~=139 then error("invalid gzip header")end;if fk~=8 then error("only deflate format is supported")end;er.pos=11;if eo.band(fl,4)~=0 then local fm,fn=er.buf.byte(er.pos,er.pos+1)local fo=fn*256+fm;er.pos=er.pos+fo+2 end;if eo.band(fl,8)~=0 then local cc=er.buf:find("\0",er.pos)er.pos=cc+1 end;if eo.band(fl,16)~=0 then local cc=er.buf:find("\0",er.pos)er.pos=cc+1 end;if eo.band(fl,2)~=0 then er.pos=er.pos+2 end;local M=fc(eo.main(er))local f9=er:getb(8)+256*(er:getb(8)+256*(er:getb(8)+256*er:getb(8)))er:close()if f9~=eo.crc32(M)then error("checksum verification failed")end;return M end;local function fp(f8)local fq=1;local fr=0;for aL=1,#f8 do local eY=f8:byte(aL)fq=(fq+eY)%65521;fr=(fr+fq)%65521 end;return fr*65536+fq end;local function fs(er)local ft=er.buf:byte(1)local fl=er.buf:byte(2)if(ft*256+fl)%31~=0 then error("zlib header check bits are incorrect")end;if eo.band(ft,15)~=8 then error("only deflate format is supported")end;if eo.rshift(ft,4)~=7 then error("unsupported window size")end;if eo.band(fl,32)~=0 then error("preset dictionary not implemented")end;er.pos=3;local M=fc(eo.main(er))local fu=((er:getb(8)*256+er:getb(8))*256+er:getb(8))*256+er:getb(8)er:close()if fu~=fp(M)then error("checksum verification failed")end;return M end;function fb.gunzipf(fv)local aT,aW=io.open(fv,"rb")if not aT then return nil,aW end;return fh(eo.bitstream_init(aT))end;function fb.gunzip(D)return fh(eo.bitstream_init(D))end;function fb.inflate(D)return fs(eo.bitstream_init(D))end;local function fw(D,cc)local ef,eg=D:byte(cc,cc+1)return eg*256+ef end;local function fx(D,cc)local ef,eg,eY,eC=D:byte(cc,cc+3)return((eC*256+eY)*256+eg)*256+ef end;function fb.unzip(fy)local eO=#fy-21-#"00bd21b8cc3a2e233276f5a70b57ca7347fdf520"local fz=false;local fA={}if fx(fy,eO)~=0x06054b50 then error(".ZIP file comments not supported")end;local fB=fx(fy,eO+16)local fC=fw(fy,eO+10)eO=fB+1;for aL=1,fC do if fx(fy,eO)~=0x02014b50 then error("invalid central directory header signature")end;local fD=fw(fy,eO+8)local fE=fw(fy,eO+10)local f9=fx(fy,eO+16)local fF=fw(fy,eO+28)local h=fy:sub(eO+46,eO+45+fF)if true then local fG=fx(fy,eO+42)local eO=1+fG;if fx(fy,eO)~=0x04034b50 then error("invalid local header signature")end;local fH=fx(fy,eO+18)local fI=fw(fy,eO+28)eO=eO+30+fF+fI;if fE==0 then M=fy:sub(eO,eO+fH-1)fA[h]=M else local er=eo.bitstream_init(fy)er.pos=eO;M=fc(eo.main(er))fA[h]=M end;if f9~=eo.crc32(M)then error("checksum verification failed")end end;eO=eO+46+fF+fw(fy,eO+30)+fw(fy,eO+32)end;return fA end;return fb end)a.register("out/utils/JsonStore.lua","JsonStore",function()local S=a.get("out/utils/JsonStore.lua")local a=a._G[S]local at=a.import(S,S.Parent.Parent,"modules","services").HttpService;local fJ;do fJ=setmetatable({},{__tostring=function()return"JsonStore"end})fJ.__index=fJ;function fJ.new(...)local self=setmetatable({},fJ)return self:constructor(...)or self end;function fJ:constructor(aT)self.file=aT;local a0=isfile(aT)local a2="File '"..aT.."' must be a valid JSON file"assert(a0,a2)end;function fJ:get(n)local fK=self.state;assert(fK,"The JsonStore must be open to read from it")return self.state[n]end;function fJ:set(n,P)local fK=self.state;assert(fK,"The JsonStore must be open to write to it")self.state[n]=P end;function fJ:open()local a0=self.state==nil;assert(a0,"Attempt to open an active JsonStore")local fL=at:JSONDecode(readfile(self.file))a.Promise.defer(function(k,K)if self.state==fL then self:close()K("JsonStore was left open; was the thread blocked before it could close?")end end)self.state=fL end;function fJ:close()local fK=self.state;assert(fK,"Attempt to close an inactive JsonStore")writefile(self.file,at:JSONEncode(self.state))self.state=nil end end;return{JsonStore=fJ}end)a.register("out/utils/extract.lua","extract",function()local S=a.get("out/utils/extract.lua")local a=a._G[S]local fb=a.import(S,S.Parent.Parent,"modules","zzlib")local fM=a.import(S,S.Parent,"file-utils")local a8=fM.makeUtils;local W=fM.pathUtils;local function fN(fO,fP,fQ)local fR=fb.unzip(fO)local fS={}for d,fT in pairs(fR)do local aD;if fQ then local a0={W.addTrailingSlash(fP)..tostring(string.match(d,"^[^/]*/(.*)$")),fT}local fU=#fS;fS[fU+1]=a0;aD=fU+1 else local a0={W.addTrailingSlash(fP)..d,fT}local fU=#fS;fS[fU+1]=a0;aD=fU+1 end end;a8.makeFiles(fS)end;return{extract=fN}end)a.register("out/utils/http.lua","http",function()local S=a.get("out/utils/http.lua")local a=a._G[S]local an=a.import(S,S.Parent.Parent,"api").httpRequest;local fV=a.Promise.promisify(function(fW)return game:HttpGetAsync(fW)end)local fX=a.Promise.promisify(function(fW)return game:HttpPostAsync(fW)end)local request=a.Promise.promisify(an)return{get=fV,post=fX,request=request}end)a.register("out/utils/replace.lua","replace",function()local S=a.get("out/utils/replace.lua")local function bt(D,fY,fZ)local f5,f_=string.gsub(D,fY,fZ,1)if f_>0 then local aL,eF=string.find(D,fY)return{f5,string.sub(D,aL,eF),aL,eF}end end;return{replace=bt}end)a.register("out/utils/fetch-github-release/downloadAsset.lua","downloadAsset",function()local S=a.get("out/utils/fetch-github-release/downloadAsset.lua")local a=a._G[S]local http=a.import(S,S.Parent.Parent,"http")local a8=a.import(S,S.Parent.Parent,"file-utils").makeUtils;local fN=a.import(S,S.Parent.Parent,"extract").extract;local g0=a.async(function(g1,d,g2)local g3;if g2~=nil then local g4=g1.assets;local a0=function(ef)return ef.name==g2 end;local aD=nil;for g5,ar in ipairs(g4)do if a0(ar,g5-1,g4)==true then aD=ar;break end end;local g6=aD;local a2="Release '"..g1.name.."' does not have asset '"..g2 .."'"assert(g6,a2)g3=g6.browser_download_url else g3=g1.zipball_url end;local g7=a.await(http.request({Url=g3,Headers={["User-Agent"]="rostruct"}}))local g8=g7.Success;local g9=g7.StatusMessage;assert(g8,g9)local aD;if g2~=nil and string.match(g2,"([^%.]+)$")~="zip"then aD=a8.makeFile(d..g2,g7.Body)else aD=fN(g7.Body,d,g2==nil)end end)return{downloadAsset=g0}end)a.register("out/utils/fetch-github-release/downloadRelease.lua","downloadRelease",function()local S=a.get("out/utils/fetch-github-release/downloadRelease.lua")local a=a._G[S]local fJ=a.import(S,S.Parent.Parent,"JsonStore").JsonStore;local g0=a.import(S,S.Parent,"downloadAsset").downloadAsset;local ga=a.import(S,S.Parent.Parent.Parent,"bootstrap")local ac=ga.bootstrap;local aa=ga.getRostructPath;local gb=a.import(S,S.Parent,"identify").identify;local gc=a.import(S,S.Parent,"getReleases")local gd=gc.getLatestRelease;local ge=gc.getRelease;local gf=fJ.new(aa("RELEASE_TAGS"))local ag=a.async(function(gg,gh,gi,g2)local a0=type(gg)=="string"assert(a0,"Argument 'owner' must be a string")local a1=type(gh)=="string"assert(a1,"Argument 'repo' must be a string")local gj=type(gi)=="string"assert(gj,"Argument 'tag' must be a string")local gk=g2==nil or type(g2)=="string"assert(gk,"Argument 'asset' must be a string or nil")local gl=gb(gg,gh,gi,g2)local d=aa("RELEASE_CACHE")..gl.."/"if isfolder(d)then local u={location=d,owner=gg,repo=gh,tag=gi}local br="asset"local bq=g2;if bq==nil then bq="Source code"end;u[br]=bq;u.updated=false;return u end;local g1=a.await(ge(gg,gh,gi))a.await(g0(g1,d,g2))local u={location=d,owner=gg,repo=gh,tag=gi}local br="asset"local bq=g2;if bq==nil then bq="Source code"end;u[br]=bq;u.updated=true;return u end)local af=a.async(function(gg,gh,g2)local a0=type(gg)=="string"assert(a0,"Argument 'owner' must be a string")local a1=type(gh)=="string"assert(a1,"Argument 'repo' must be a string")local gj=g2==nil or type(g2)=="string"assert(gj,"Argument 'asset' must be a string or nil")local gl=gb(gg,gh,nil,g2)local d=aa("RELEASE_CACHE")..gl.."/"local g1=a.await(gd(gg,gh))gf:open()if gf:get(gl)==g1.tag_name and isfolder(d)then gf:close()local u={location=d,owner=gg,repo=gh,tag=g1.tag_name}local br="asset"local bq=g2;if bq==nil then bq="Source code"end;u[br]=bq;u.updated=false;return u end;gf:set(gl,g1.tag_name)gf:close()if isfolder(d)then delfolder(d)end;a.await(g0(g1,d,g2))local u={location=d,owner=gg,repo=gh,tag=g1.tag_name}local br="asset"local bq=g2;if bq==nil then bq="Source code"end;u[br]=bq;u.updated=true;return u end)local function ae()delfolder(aa("RELEASE_CACHE"))ac()end;return{downloadRelease=ag,downloadLatestRelease=af,clearReleaseCache=ae}end)a.register("out/utils/fetch-github-release/getReleases.lua","getReleases",function()local S=a.get("out/utils/fetch-github-release/getReleases.lua")local a=a._G[S]local at=a.import(S,S.Parent.Parent.Parent,"modules","services").HttpService;local http=a.import(S,S.Parent.Parent,"http")local gm=a.async(function(gg,gh,gn)if gn==nil then gn=function(g1)return not g1.draft end end;local g7=a.await(http.request({Url="https://api.github.com/repos/"..gg.."/"..gh.."/releases",Headers={["User-Agent"]="rostruct"}}))local g8=g7.Success;local g9=g7.StatusMessage;assert(g8,g9)local go=at:JSONDecode(g7.Body)local gp={}local fU=0;for aq,ar in ipairs(go)do if gn(ar,aq-1,go)==true then fU=fU+1;gp[fU]=ar end end;return gp end)local ge=a.async(function(gg,gh,gi)local g7=a.await(http.request({Url="https://api.github.com/repos/"..gg.."/"..gh.."/releases/tags/"..gi,Headers={["User-Agent"]="rostruct"}}))local g8=g7.Success;local g9=g7.StatusMessage;assert(g8,g9)return at:JSONDecode(g7.Body)end)local gd=a.async(function(gg,gh)local g7=a.await(http.request({Url="https://api.github.com/repos/"..gg.."/"..gh.."/releases/latest",Headers={["User-Agent"]="rostruct"}}))local g8=g7.Success;local g9=g7.StatusMessage;assert(g8,g9)return at:JSONDecode(g7.Body)end)return{getReleases=gm,getRelease=ge,getLatestRelease=gd}end)a.register("out/utils/fetch-github-release/identify.lua","identify",function()local S=a.get("out/utils/fetch-github-release/identify.lua")local function gb(gg,gh,gi,g2)local gq="%s-%s-%s-%s"local a0=string.lower(gg)local a2=string.lower(gh)local gr=gi~=nil and string.lower(gi)or"LATEST"local gs=g2~=nil and string.lower(g2)or"ZIPBALL"return string.format(gq,a0,a2,gr,gs)end;return{identify=gb}end)a.register("out/utils/fetch-github-release/init.lua","init",function()local S=a.get("out/utils/fetch-github-release/init.lua")local a=a._G[S]local ap={}for aq,ar in pairs(a.import(S,S,"getReleases"))do ap[aq]=ar end;for aq,ar in pairs(a.import(S,S,"downloadRelease"))do ap[aq]=ar end;for aq,ar in pairs(a.import(S,S,"identify"))do ap[aq]=ar end;return ap end)a.register("out/utils/fetch-github-release/types.lua","types",function()local S=a.get("out/utils/fetch-github-release/types.lua")return nil end)a.register("out/utils/file-utils/init.lua","init",function()local S=a.get("out/utils/file-utils/init.lua")local a=a._G[S]local ap={}ap.makeUtils=a.import(S,S,"make-utils")ap.pathUtils=a.import(S,S,"path-utils")return ap end)a.register("out/utils/file-utils/make-utils.lua","make-utils",function()local S=a.get("out/utils/file-utils/make-utils.lua")local a=a._G[S]local W=a.import(S,S.Parent,"path-utils")local function gt(gu)local gv=string.split(gu,"/")local fU=#gv;local aD=gv[fU]gv[fU]=nil;local f4=aD;if f4==nil then return nil end;local cM=table.concat(gv,"/")if cM~=""then gt(cM)end;if not isfolder(gu)and not isfile(gu)then makefolder(gu)end end;local function gw(aT,gx)local gv=string.split(aT,"/")gv[#gv]=nil;gt(table.concat(gv,"/"))local aE=W.addExtension(aT)local bq=gx;if bq==nil then bq=""end;writefile(aE,bq)end;local function gy(fS)for k,bw in ipairs(fS)do local d=bw[1]local fT=bw[2]if string.sub(d,-1)=="/"and not isfolder(d)then gt(d)elseif string.sub(d,-1)~="/"and not isfile(d)then gw(d,fT)end end end;return{makeFolder=gt,makeFile=gw,makeFiles=gy}end)a.register("out/utils/file-utils/path-utils.lua","path-utils",function()local S=a.get("out/utils/file-utils/path-utils.lua")local function gz(d)local a0=isfile(d)or isfolder(d)local a2="'"..d.."' does not point to a folder or file"assert(a0,a2)d=string.gsub(d,"\\","/")if isfolder(d)then if string.sub(d,-1)~="/"then d=d.."/"end end;return d end;local function gA(d)d=string.gsub(d,"\\","/")if string.match(d,"%.([^%./]+)$")==nil and string.sub(d,-1)~="/"then return d.."/"else return d end end;local function gB(d)d=string.gsub(d,"\\","/")if string.sub(d,-1)=="/"then return string.sub(d,0,-2)else return d end end;local function gC(aT)local gD=string.match(string.reverse(aT),"^([^%./]+%.)")~=nil;if not gD then return aT..".file"else return aT end end;local function gE(d)return string.match(d,"([^/]+)/*$")end;local function gF(d)return string.match(d,"^(.*[/])[^/]+")end;local function gG(gH,gI)local a0=function(aT)return isfile(gH..aT)end;local aD=nil;for g5,ar in ipairs(gI)do if a0(ar,g5-1,gI)==true then aD=ar;break end end;return aD end;return{formatPath=gz,addTrailingSlash=gA,trimTrailingSlash=gB,addExtension=gC,getName=gE,getParent=gF,locateFiles=gG}end)a.register("out/utils/file-utils/types.lua","types",function()local S=a.get("out/utils/file-utils/types.lua")return nil end)return a.initialize("init") end)()

Rostruct
    -- Download the latest release to local files
    .fetchLatest("richie0866", "MidiPlayer")
    -- Then, build and start all scripts
    :andThen(function(package)
        package:build("src/")
        package:start()
    end)
